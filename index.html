<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92b1b8144a8f4ca1a1deb80568c09e035054d334e8385d4e7229cb7e291a1c33c9a2553beecc7e7c7c47515a73a178ade410a2ed06b0460ff31a72290b877d7112352183b4114c1760d6faccc65ed45173ef1f35ab4c10cb35bb81ba725895e7a353db4a376c33d37125defca36688262004d77074bc4b7db4f2cb98b8f38a4a0c2892dc4100e775ff90b4b53c111bedf2254b9d25295c1c69cd89937ca714ebec64d93c4cfc0ac7c68fcb72ad057b15c6d33f6fb35340af8ffe4d28c928dc944e12878c209d53435cba1825cdceb09d9543ed34cf584cef092b518b6c67a591b6b2503a1cd167261fec09ff505fb7e270a0989311d0301a4fc8c3a0d44fbf654963e4b0eff0e3ef98235962030abb3119cf58deeee62a5f7a7d59425b47ebac86b929ba49591026bdcd4e40840335d0cd89c83bb374e4d0cd096d72c98880c872f929fea0a22319b5c8ef55981b53c4a4ebfd092207f120ce234fce54c8fcd33e133da7c327d3256bead77ed534510ae9bec7b84fabe6990ec107a4754be593a7f3cdd423d645a1954649f60aa054cb4ff81d8545af73faad78a8775453374f5309d5c5057b5f5c960a4e56aaa0638558d1eb7d0965a5d8cae658d87ff470be21d2781cdaa1d6e0d257e10f7e0ed9c65515a7c9612e2ebd3b9515cf0aac704108f662b0e4bd4a6f61d609b967b2a1d50ccd01e760e307c6ff1c78666a4f70f98c32907d4195b5c9b0177d2d54be0550737e60c2a23250d07de01f55c3555e2627755004f05c02aa513ab08503266e8b26593ec152bcc4ae29fae06e02a1ad0bfd28b5c66095b3212e37f712111975bc9366dd82df23d1dab26128567a100e1d46996996cbbad4b1a5c610e6839b374015dc5f6492edf3a449d04b49831f2059dc54ee7cd113a523005b196aba80bb131590d88ba7e507f81369fbdefe199c21bae75bf1ce0b7851755f2b361eee343cd915e582c72a5fc83c1edaa916e934a0ab192567126c6411c02f310362ca55300edd848b56b337a159b194b1b744aa41032132c9bbf0b1f23737386cfc017c6a4914575de56935cf139a3ebbce8dc0273da39cdbf937aee55b1c973beb7c1ad01272e00624ea1a78c43c18f35e3326a9dfd61c839ae500548d39519330175f8b16716e6b2af2d7833ea954d4d969c16e9774b01a9e619b067baf0017a0969078ab533d9ca5a9d5911113931c83bbd769e8d2e9c424aafb0213c9caf9d8dee67ad64872f15f24a82663f835fa8ff994eb8fbdffbe9aa68e17067502f2b131d925fa74a66f24dde781b399c6f681068dfb65babffda8d6b9a97c56c751bece143fa7ef3f4027c3b23706abd4eaf4ec07c50041df9bc835076b168f6c80d2156b7ffeea6f5a18a6f5b14769da70c9568d50a63ebdb15ac949c557ec358746195e660949dff36eadd9b92b19fb0de912e8b5071b395ad0b3fc05a98f79b34c8d18474e68e117f76482498e7d4599c52e01fa2586f760c15dc65346cbc087d5612b83ea26060649cba0a474c70a65427b143d37c64014a08d0a0b19ffc111379a8d88c2fccebf5f168ce649bc89b93cfceb0f23cef9f41079ac4deb57d77b8f9755eed4fccdf4a8513464fe70ef1b03d272a92e14f6d6549f4811ad4177cccafa99cec43af369a2df17123b7a04a6fe642b68876d526d4f7d705b7d3a1c5153f630741b10e2ef3a4ba35df4c0cec34cb22cab46e307ea7eb73fc5afb7817458bf1e7dd8ef964332ea7c8bfb7ddd6cf411a80c0d251967c8f554b9dbe24b470d338701b2bcc348c6353cf2356c2805da0cbe4d5072d8bb0e9b34b2627ea25918312966709cb1e5cac91bfeeea1a42fa5fc6519a511ed71fb8fda7277ca593e7e7d55ba776e151508c6abfe508f1cc5ff9222bba20da7e93632abd94e2622c19f9614700a7548d2ec2b76641f171bf2d533a563c4ddb6c177b6abdfea7b647f623fbd1967733e561e792746a216eaa30e1629524d4548ffbe3d4f787baef4b10eca0f4c3b0c06fe34c7805ea8788f9dee7bcb685dd18cb2b9f5040a15e8600bc25aa27abdbdd16bbf5566fd1da3fe59bd78dc7ba97ccf8c234d23b5f2d3648ff1e2b884b4fcdbc6fd426fc1864d57f1df14bde041f463b0bc3515f730ce258f1da0d96904f007f1cc9c84c9ab453aed68a0a80c1d3502d04325e22491fb5eaa34ab7abe6adc2b5a99f1fdffc5398b45213602bfaf35fe343ec640d9b1313c0840ba1e7a0bb3d5d9282bb94372e43b4bc1b139505756eb3256cf9c78b026ce403c7491376dd74862bc36af05f9d955c96c386f5ab0529b79b35c718b22e64724fc6ce84061e5efd6f70996ac238f3ff70306f6c2b26b2d4448d333f28a1590c94c5e1ea0222ffabeea44b8a5964444e99c28e43385f775bd4ae803686348a2ae381e6d122a0fc88deb9cf8f0465b91074d5f9a1fa511d5fb5a3e4e3d1f3fd63a95aade2292c6ee799c29bd27ccca7b1e493b556bbf2a2ed070ec227e42c58f85c89386ffdacf7a9f83f85dd71ccde9cb70c8e1a47b86e61a4a0c5a88ce79ecf50bd70e8dd48bb1cfd476b0d1b6718cf82909409d592733a55e1dc464b25f2e3f1eaef2d416055e8f8b73392ce2869f7695a5dbb25001973945658e0189997f69a27e95515cac6ef798c008b9aafb481dc8fb8b2f20bc8f6d0940be4fca4aecb8b707b3614fe8016c7f06973fe2900f7ba492d585f12cbe9deac6bac62ed09a2b9efd69cd93805d854ae32ff60095bd7fcecae7c6069518b6f58d3ee71e532d435ce4b07a75da9e80dc1a33cc8b72417a74c6e84b191502e993e251e0905a1b9332b5ef0d3682344a30dfe55c87b388f5b066122fe3f9dafa157b55e93b552dabc0ee715a692965e38e7e415dfc9bfc9438d3cc6c833d043c3bc23a763bfecc3db1f63d42080ffaa7e8ecc044224da6f2459939e6d2f346374cff0b48737980e5b7c5045ff11ca9b80ece577a743cb4eb940b41d6906645a496373dca746415dbb1357134b49fecde9b867b0c373aac5c529925726e851cc9b9866b2d1e8d60f8f5c00da45d10bd218ac87e2d5224b5efd04374545e9ad60cc5cc7e6f36f1ef470667b4ee30a2ad7b19813e064cea0f45e728d99d7c236b2907ea6ef2d1e34cf121303566e0d88eb8d3116448ca7153c259f73089bd5c7f10cb51db49e1dc6c621eb41e88c5d3094e4e8aa62a6d5d84beadf5a372bbe126b2d1d2b8bd838dc227b56faeccd0858ea58a56988957607b98f78a917c7afd312191cc0ca7af7baf43eb4f0c812ede9faa13009c9613df1cdb4e70d80957625c13bfce7c3f3bfe5dd893cf9c9b24f34770fe7767a2e09094e5da2994d14759d60a955ed0082ce5cf809527e3fad43e15a04afe1e70d38b8e705ad5fc161c89ffac8b66b102ae41dd1120521b452ca545b1a74bb646502667be1667c1d5cfe39fdce0641a3f121dbea78e6381348e1109bdd004634ada25c69284703d4c6f5f09b9c3cf77aa3464679c300c70ae4218ca1043f2d733991fd9e5581494658bd5dfbc8f7739eedcbff581b190d988bbfa5063e778c0161553afb6eee6dd0cdfdecbedff94170dc3f59c1347ca90bdafa10a0110b8d94dd8025b30e01262368c7d0fa0074f70e69c7d011f6b7c174bfd55215d67b56000b1eae6021ef3cad129df6b5e001b7ccae2e266cfc2c2fea47fb55ec0cb6e51d2d214c6447407ed0a60050c88b570f59225b913d4ae6f3f8c8dcb3011182ceba151cbadc6a61300bcfaeeb8618d874a655befabced06fb1de57bf7f5e9b9be1cc967bc3732c29a8572f37b49b56e4fb26f2c4e311bf78a04b48a1521b313346cd80817e3a9db96d9bc08fec990d80e42c1e30baf3abca6d5509a7ebbfa8c8518fbdfcdab6cf41345890a014ee47978da825c2fec75868b3c583d8ba728861f4ecb67ec4cb1c06878ace59880751d197e37a7c99ce26b8560deb00133e4f139f55b75ce5357b1022425e41ecba4c11a4eec2939734f1b8d1a03ab125552b3be9d753755ec3819e7c5ddb4a21d215bd65942a4dbf81689f313076ebb250ab1e0fd34487960a765483c92a2cfbd4f1d5b395be299ae318740be29c4426c00478c8d199d3cab5653dfa02ec358ccb3b6fe4425fd8e78ec9e18aa9d8a0878fe9c61c5547e9dc005ceff2bbe3804f14b2963538bd692b9f428d8e1c9e091f01b27bfc42ba5e427c82e5cbf16962b6f3b577617ef9f4c30615178a2c6970a666e1cd0d60842936606343805a6d9687b6e0d007d222a6406e934791df82320618ed06695f839cb66af8964808f22b4ee850fc7df0389f0fbe2531849a73aa1419227132fb3ea2cf5eafc3889344dc35be8977214db2f5db9468ac66b4b50db47d03f8e520f1b982faf35d79e7f159716de41b71e151d767dfbe24d42f9240aadfadb8f91718ad3cf9bd35a672cb6a48c3401310fe54c84a03083ca70da79b14843c8dab843ce117043d36624d5e06703af347a26c45c7d6101739987de2f753cd7695b10f3e9560eb77e54a53c30ef22762281954f90504f9be7790bd87b04142d7ce6fddb509709a679289338d9c57c6edf713d98c4b8784e1c0c215d7e4e00b39868a2cab48f1cf6f5a15873e07e04e1fbab5d26413b8993826bcb72743d8549405060d53a14fa893489183e5746f6705d1dae7848e4ede35f173def539d582ed80c7c2ca761cdba637fa255c580e25030655f6409901add26f9f21ea792b679ed46df58044f87157bf2282682a15661b2cecb1a07df6db89580e3aed3e0ea6fd2297a5faea97cf0ecc74629886f75df270c4c6c5d1ec2f66dc87880981e4b5280c986041aa65d9b1c4fbc3613e88dc2ad39f339f1972062c92d94d45d985a8ef56473b985c16bf890c2c1a5d0380210affb219121ad59bded1884f837d80597b054abc76cd71b4760ccf8d1fdea70b9930edff500c6d69bd45734f255d7667986b5096c951c603f7d3ead28f3ffd30fb4072fec0a17f2389170d9e32ef34792db4d7a9306bf24db495f087bf954e635d16f4dbb41fd6eaf445a2eaaa3390425e194bb2dfaa84c3139676c342d7e669f2a4e203b8b8bf2fe78a73464385ddd01554c046f609ab201c2bfc1ccaf0c31a14376af65497888a074b69ed80a1e244ee083d83842bd36fb23ce0d4fc89cc734846b63b138e6112cd35c4262cff19db45bd23e34ccafabd3f0482a46ed26a18f20625321d044fe40959df45394934930ba3457913c378bfb1382c76e60c2e7c73f7a14910b4bc871f8035d5b41d31b45a3400d98318605ed1286dd012c39525d13135f2f4c5a24443caa93046e645afc5f8153d59895c9ab553a0923cf61213ec30d9ed674f64c2bcaf43314c0b74f3b90eb116ad10a4a9e051a2152fb7076b9d4e683e5357b1225e5d6941a2a0eb6a2a1da8972687a02c182ea2e6cb1c4b45f175c6ab9801899390fd58b4d020910b7485f7883d595b82175858e7324c80c8ca36a7ad1260667366a93394e56969e96751fcee43b68792ce500ce986090c343a5a42a87f2cef1222891428a8b11c62fba357779873c4bda14ad7fb1e00b4de6f24f8eaa0989b5af1803860a89943056b06d07ecc592bcf9e444673c992a4dbf77a7b0fa9ccc1557082fada251f9397c6be6a68c0ff1f9ffd209ecaf8b6f48836dc32f7cdb5046b2de1bbe2e32af1b67eb8f13bafe68379f62332fc2d056021f1b1294d75cce545832a67cef40e1f8b22d50b72d660e7690ed07e7a15e6dc63da09be8b59ac6bcb393e16d5da239466d3be17c3f00dbbc56581603af060a4ab1f337120f0d1bb691aa0520637020d71eb5d4d8c1b4e3e2ab6374c282575a198904d3e9f6a7afd6a58c56e642abd973961e8eb07cbe0704d817d05d3dea41aed15c470ea3f9756bbf8cb92d96a8b7e1687a46d9a52c07efc513e81a2013818e6ead1d3ed410aee30f1e7b50f2eb72edb0aa0c5eb249281973a76ee4961785fa898a95b03b992978fb9b4e35ad0d83ee7058272a21b003a81d55981e9de6e2bc84316286d2a81f4a3f454fd90dd14e3ac3269eea4830eeb48c59aaf3ecc7d2f6e283d1572e18b32908d0ce6a69f4d04ed5de06f60d7818c2ef868135c58ab0b0fc2cfc89184d021bd08915509801ff07304e349d121a3614ecabafcec67d90364b60ac3ec9853570ad45f64484f362b53108d1b785271bab41a4bbee89d9bcb8353e1ad7bde47a013f5b3ff62fd0f7b1d59c0dc52b70e50ef0327c7ee9dfaf48d6a780099bf5b0c22596d57b91964f0ba5a610da5213345ee5a9312405791328780aed3c6e3b076add75d6e5f4be068ceabb9aaeea61b353749e8e44595e9ea5f729b15edd9f0a9d7a26d184a2db96cd6a9ab13be569b7d2dce4d78e10bc19acc1e9dd3283c2c6f2ed6fe08a1368960232587855686dcd0680f6083bbf2d36061c61aba20d333afd848ad993d496a1f9ca5b64ec957088a58ad5f5beb0b20ea36ea81ecf9df628eb825bda18fba24d17f0cf0cff893b9e5ca045ec0ea0c8ba51a309dbe7700d6d880142bed7a5980aaef2b384acbffff3e01ae2e10e78d96e6aaa347ab225b50112a93e49fd70fda83959f8cb83fd60fe198513870808fc8163e9f290ac12bf46c3ab49cd618977ebe51aca8e5de21e90f95517d9acba9427453b3dd80f7a3ba80ef0a4e7476ff4eaa687701997d4dc3a4dce0c9ed06d535764f458fd26374366c8d617a836bf83b66eb7a26938910069b8508c5ab15309fd582c073e8cff8965137c6d15d28b1d219d3603f47433124fdb36f58047a91d7b7dbd92ce96d72ce64b6471e08c4c745273e2f5fd16ef307ed8c58acfe315b8ab5fcb0b4fd0176878fafdb643403fe31adac4624c994702eedfc6cf545f20035d611501e8d98472fa5aaa0c97e83c65c192bde217fdf9dac8c14654be307b791cf2e83b8f0493e798a06345188b8556084b28e9a1f87dd6909cd7c1aad5cf7d47d4075c51ebca16735f71dee9d8e0cffcc61a2586f140921015e12e83dd159ff5e231da0a6e8c05fba0212a301053aa334b8ff4b3adf31d69abca87ee2b41b242ebc75566e6c3811a6240f1d757d23e76b51d08b225e0a4d2567efd1af9241f6f3434a06799c06701eb15ff84923a58ceabf65a843fa8f1acd5c6d7c5e6231334a32b2c84db661fbf31c92c9a8c80d997ab6ffe75537a3304e9ab81f3493959d7b92111690365aee224456408049a8312d5140883363a229c33d1641365bdedb98c7e8f344c331d0c82c3af5f8f58284d1613f30b8f54f1807c4de20abb7edcd44cc123e691b7aa8437450ffdbd4a7b1ae535dc7f73745764c0f92b94f78e95017787707588790945d174804aad6e3c012666d580ff53583c5b74f4b2a860f6414fd29d6faf74373529f5e592a25995ccf0c8c0fe14d1fe9189e3b240fcd2149b2f154c4a53df5a75851186e22c8b0daeb6da9e0bf673b21d2bc178f860bc95add5a672511550e256b55f887599d25cc19f490843453558fccbfef0a1c323adf404e0b86873034190bd1307e537b1154e23beb5b2bd6d93f38178e6b9d423bb6d1c4ee8246cd6d57efbaeaf432a85305878721d36c92cc946aa35a8c3bdb9a405e0f7e17fcb2bf8186a49f4c6c698bfc08d65773704808a7b42b00329a1a28336b9842f7d5f3c7c03f5335208eec4c3030cf058dda456d8e288092e0b1f78f7a0b8c8d4a5716d79e003e1410e6203829e35f7900d4640adc7226fe630e9d7f51554e1ead34b93c890dee3e6a406eff38b1f5ddfece1ecd0797003c1000a7771b620042234ae06dce1c0a72b56bd0ed970f28e427286e93e0992704ba3d959d1f20ed50e545f1972674ac0b07714cee0bb0d39de25efbdb833fdd2630e0b3e38f21a01ceae209c34054bec660cc28674d6125e2d847a7d6fe0cf839ca923bdb697384405375f894d3476a62e8d1583cbb97e3e70b8f5cfdad755a605827811f4ea784ed20e25f27e567894181a90238a47d9606f5858a205e1bcf78f9de003e23163a4337b757cf7cb924853155b7eced5886575a6091684969225a40d91d3c4dd96699ded4b21215ab69ef72cf0cc6a2215bfe9253bbca047258227229a6d4ce6bab54ce0669ddf893a7c1646f788544eacd542d619e73697d390a8e04f9d1d53a2988b1b75a529fc0bb3eae8ae233bcdc0967ce12ea09df43a1aa57da372b7f56e86a406dcbec6bae4a14aeb699761b039052c6f122d8f27e789f9bd3c8f7e47d2f037dccc2ff5f1e574791b76f446de6bd1644c20011c0f91cdbce56a14e79ae505f33e54212deee9b48cb5b67aff187422a2cb6b13bd79eb1d0fbe2e2c6ad406a70d3b835b831f9a99d11db6ea49a7bd419b972e9b354e7076d93647d7ff3ba7544e4330f9aeceb5d41614880a34dd5a42d8dc4bb44209b71109a0b5b17811d48d86454f29d7619bf89f077682b2e9074828fa9b3640436c934a0ea07fe23ca7c5029841d9a8fb9d5e43defe59ebda58cdb86d53fbf026d636a818640bf1be65d75bb2e19ec991d276e0f0914f1d59ce421bfe3b8aa07cc3604336f273d156e46ea324cae1ad4256dd1ff39c6ee0d2d09907d4108369dd403ab0ec0811f6764d9d3212c6e9bb54c75b248b3471ef69f5731f2cf3b2fe2acb8226db41fd957f09eefb5cad4cf1ac463c718eb14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c2e774bfa1df53966e5439d67b2f2607"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
